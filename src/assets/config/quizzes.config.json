{
  "quizzes": [
    {
      "id": "quiz-angular-fundamentals",
      "courseId": "angular-fundamentals",
      "title": "Angular Fundamentals Assessment",
      "description": "Test your understanding of Angular core concepts",
      "passingScore": 70,
      "timeLimit": 30,
      "questions": [
        {
          "id": "q1",
          "type": "single-choice",
          "question": "What is the purpose of Angular's dependency injection system?",
          "options": [
            "To manage component styles",
            "To provide services and dependencies to components",
            "To handle routing between pages",
            "To compile TypeScript code"
          ],
          "correctAnswer": 1,
          "explanation": "Dependency Injection is a design pattern used to provide instances of classes (services) to components that need them, promoting reusability and testability.",
          "points": 10
        },
        {
          "id": "q2",
          "type": "true-false",
          "question": "Standalone components in Angular require NgModules to work.",
          "correctAnswer": "false",
          "explanation": "Standalone components are self-contained and don't require NgModules. They import their dependencies directly.",
          "points": 10
        },
        {
          "id": "q3",
          "type": "single-choice",
          "question": "Which decorator is used to create a reusable component in Angular?",
          "options": [
            "@Injectable()",
            "@Component()",
            "@Directive()",
            "@Module()"
          ],
          "correctAnswer": 1,
          "explanation": "@Component() is the decorator used to define Angular components.",
          "points": 10
        },
        {
          "id": "q4",
          "type": "single-choice",
          "question": "What is the purpose of Angular Signals?",
          "options": [
            "To make HTTP requests",
            "To handle reactive state management",
            "To create animations",
            "To define routes"
          ],
          "correctAnswer": 1,
          "explanation": "Signals provide a reactive way to manage state in Angular applications, automatically updating the UI when values change.",
          "points": 10
        },
        {
          "id": "q5",
          "type": "true-false",
          "question": "Reactive Forms in Angular use the FormBuilder service to create form controls.",
          "correctAnswer": "true",
          "explanation": "FormBuilder is a service that provides convenient methods for creating FormGroup and FormControl instances.",
          "points": 10
        },
        {
          "id": "q6",
          "type": "single-choice",
          "question": "Which lifecycle hook is called when a component is initialized?",
          "options": [
            "ngOnDestroy()",
            "ngOnChanges()",
            "ngOnInit()",
            "ngAfterViewInit()"
          ],
          "correctAnswer": 2,
          "explanation": "ngOnInit() is called once after the first ngOnChanges() and is used for component initialization logic.",
          "points": 10
        },
        {
          "id": "q7",
          "type": "true-false",
          "question": "The @if and @for syntax in Angular templates is the new control flow syntax introduced in Angular 17.",
          "correctAnswer": "true",
          "explanation": "Angular 17 introduced a new built-in control flow syntax with @if, @for, and @switch, which is more performant than *ngIf and *ngFor.",
          "points": 10
        },
        {
          "id": "q8",
          "type": "single-choice",
          "question": "What is the purpose of Angular's HttpClient?",
          "options": [
            "To create HTTP servers",
            "To make HTTP requests to backend APIs",
            "To handle client-side routing",
            "To manage browser cookies"
          ],
          "correctAnswer": 1,
          "explanation": "HttpClient is Angular's service for making HTTP requests to communicate with backend APIs.",
          "points": 10
        },
        {
          "id": "q9",
          "type": "single-choice",
          "question": "Which of the following is used to protect routes in Angular?",
          "options": [
            "Interceptors",
            "Guards",
            "Resolvers",
            "Pipes"
          ],
          "correctAnswer": 1,
          "explanation": "Route Guards (like CanActivate, CanDeactivate) are used to control access to routes based on conditions.",
          "points": 10
        },
        {
          "id": "q10",
          "type": "true-false",
          "question": "Angular services should be decorated with @Injectable() to be used with dependency injection.",
          "correctAnswer": "true",
          "explanation": "The @Injectable() decorator marks a class as available for dependency injection.",
          "points": 10
        }
      ]
    },
    {
      "id": "quiz-product-analysis",
      "courseId": "product-analysis-basics",
      "title": "Product Analysis Fundamentals Quiz",
      "description": "Assess your understanding of product analysis concepts",
      "passingScore": 70,
      "timeLimit": 25,
      "questions": [
        {
          "id": "q1",
          "type": "single-choice",
          "question": "What is the primary goal of product analysis?",
          "options": [
            "To write code faster",
            "To understand user needs and improve product value",
            "To reduce development costs",
            "To increase team size"
          ],
          "correctAnswer": 1,
          "explanation": "Product analysis focuses on understanding user needs, market trends, and data to make informed decisions that improve product value.",
          "points": 10
        },
        {
          "id": "q2",
          "type": "true-false",
          "question": "User personas are fictional representations of your target users based on research and data.",
          "correctAnswer": "true",
          "explanation": "User personas help teams empathize with users and make user-centered decisions.",
          "points": 10
        },
        {
          "id": "q3",
          "type": "single-choice",
          "question": "Which metric measures how many users continue to use a product over time?",
          "options": [
            "Conversion Rate",
            "Retention Rate",
            "Bounce Rate",
            "Click-through Rate"
          ],
          "correctAnswer": 1,
          "explanation": "Retention rate measures the percentage of users who return to use the product after their first visit.",
          "points": 10
        },
        {
          "id": "q4",
          "type": "single-choice",
          "question": "What is an MVP (Minimum Viable Product)?",
          "options": [
            "A fully featured product ready for market",
            "A product with just enough features to gather validated learning",
            "The most valuable player in product team",
            "A prototype with maximum features"
          ],
          "correctAnswer": 1,
          "explanation": "An MVP is a version of the product with just enough features to be usable by early customers who can provide feedback for future development.",
          "points": 10
        },
        {
          "id": "q5",
          "type": "true-false",
          "question": "A/B testing is a method to compare two versions of a feature to see which performs better.",
          "correctAnswer": "true",
          "explanation": "A/B testing involves showing different versions to different user segments and measuring which performs better on key metrics.",
          "points": 10
        },
        {
          "id": "q6",
          "type": "single-choice",
          "question": "What does 'Product-Market Fit' mean?",
          "options": [
            "When the product fits in the market budget",
            "When the product satisfies a strong market demand",
            "When the product team fits the company culture",
            "When the product matches competitor features"
          ],
          "correctAnswer": 1,
          "explanation": "Product-Market Fit means creating a product that satisfies a strong market demand and solves a real problem for users.",
          "points": 10
        },
        {
          "id": "q7",
          "type": "true-false",
          "question": "User stories follow the format: 'As a [user type], I want [goal] so that [reason]'.",
          "correctAnswer": "true",
          "explanation": "This format helps teams understand who the feature is for, what they want to do, and why it matters.",
          "points": 10
        },
        {
          "id": "q8",
          "type": "single-choice",
          "question": "Which framework helps prioritize features based on value and effort?",
          "options": [
            "SWOT Analysis",
            "RICE Framework",
            "Waterfall Model",
            "Agile Manifesto"
          ],
          "correctAnswer": 1,
          "explanation": "RICE (Reach, Impact, Confidence, Effort) framework helps prioritize features by scoring them on these dimensions.",
          "points": 10
        },
        {
          "id": "q9",
          "type": "single-choice",
          "question": "What is the purpose of a product roadmap?",
          "options": [
            "To show the geographic locations of users",
            "To outline the vision and direction of the product over time",
            "To document past product failures",
            "To track daily development tasks"
          ],
          "correctAnswer": 1,
          "explanation": "A product roadmap communicates the strategic direction and planned evolution of the product.",
          "points": 10
        },
        {
          "id": "q10",
          "type": "true-false",
          "question": "Qualitative data (like user interviews) is more important than quantitative data (like analytics).",
          "correctAnswer": "false",
          "explanation": "Both qualitative and quantitative data are important. Qualitative helps understand 'why', while quantitative helps understand 'what' and 'how much'.",
          "points": 10
        }
      ]
    },
    {
      "id": "quiz-advanced-angular",
      "courseId": "advanced-angular",
      "title": "Advanced Angular Patterns Assessment",
      "description": "Test your knowledge of advanced Angular concepts and patterns",
      "passingScore": 70,
      "timeLimit": 20,
      "questions": [
        {
          "id": "q1",
          "type": "single-choice",
          "question": "What is the primary benefit of using Angular Signals?",
          "options": [
            "Better SEO optimization",
            "Fine-grained reactive state management with automatic UI updates",
            "Faster HTTP requests",
            "Improved routing performance"
          ],
          "correctAnswer": 1,
          "explanation": "Signals enable granular reactivity, tracking state usage precisely to optimize rendering and update only affected UI parts automatically, unlike traditional change detection.",
          "points": 10
        },
        {
          "id": "q2",
          "type": "true-false",
          "question": "OnPush change detection strategy improves performance.",
          "correctAnswer": "true",
          "explanation": "OnPush limits checks to input reference changes or events, skipping unnecessary change detection cycles and boosting performance in complex apps.",
          "points": 10
        },
        {
          "id": "q3",
          "type": "true-false",
          "question": "Angular Signals integrate seamlessly with RxJS for advanced reactivity.",
          "correctAnswer": "true",
          "explanation": "Signals complement RxJS by providing synchronous reactivity that can combine with observables for hybrid reactive patterns in performance-critical apps.",
          "points": 10
        },
        {
          "id": "q4",
          "type": "true-false",
          "question": "Using trackBy with ngFor is a key RxJS performance pattern.",
          "correctAnswer": "false",
          "explanation": "trackBy optimizes ngFor by reusing DOM elements based on unique keys during list changes, reducing recreations; it's a core performance technique alongside RxJS usage.",
          "points": 10
        },
        {
          "id": "q5",
          "type": "single-choice",
          "question": "Signals eliminate the need for manual change detection entirely.",
          "options": [
            "True in all cases",
            "Only in OnPush components",
            "They enable fine-grained automatic updates without manual intervention",
            "False, Zone.js is still required"
          ],
          "correctAnswer": 2,
          "explanation": "Signals allow Angular to automatically detect and update only dependent UI via pull-based reactivity, minimizing manual change detection needs.",
          "points": 10
        }
      ]
    },
    {
      "id": "quiz-user-research",
      "courseId": "user-research-methods",
      "title": "User Research Methods Assessment",
      "description": "Evaluate your understanding of user research techniques",
      "passingScore": 70,
      "timeLimit": 20,
      "questions": [
        {
          "id": "q1",
          "type": "true-false",
          "question": "User interviews are a qualitative method for in-depth insights.",
          "correctAnswer": "true",
          "explanation": "User interviews involve open-ended discussions to uncover experiences, needs, and behaviors that surveys might miss.",
          "points": 10
        },
        {
          "id": "q2",
          "type": "single-choice",
          "question": "Which is NOT a common usability testing method?",
          "options": [
            "Lab usability testing",
            "Contextual inquiry",
            "Guerrilla usability testing",
            "Code review sessions"
          ],
          "correctAnswer": 3,
          "explanation": "Usability testing methods like lab, contextual, and guerrilla focus on observing user interactions; code review is a development practice, not research.",
          "points": 10
        },
        {
          "id": "q3",
          "type": "true-false",
          "question": "Research planning should start with defining goals and stage.",
          "correctAnswer": "true",
          "explanation": "Effective planning maps goals to methods—generative (e.g., interviews) early, evaluative (e.g., A/B tests) later—for targeted insights.",
          "points": 10
        },
        {
          "id": "q4",
          "type": "true-false",
          "question": "Moderated usability testing provides richer feedback than unmoderated.",
          "correctAnswer": "true",
          "explanation": "Moderated sessions allow real-time probing and guidance, yielding deeper qualitative insights compared to independent unmoderated tests.",
          "points": 10
        },
        {
          "id": "q5",
          "type": "true-false",
          "question": "Tree testing evaluates information architecture.",
          "correctAnswer": "true",
          "explanation": "Tree testing assesses navigation and labeling by having users find items in a site map prototype without visuals.",
          "points": 10
        }
      ]
    },
    {
      "id": "quiz-rxjs-mastery",
      "courseId": "rxjs-mastery",
      "title": "RxJS Mastery Assessment",
      "description": "Test your knowledge of advanced RxJS patterns and error handling",
      "passingScore": 70,
      "timeLimit": 20,
      "questions": [
        {
          "id": "q1",
          "type": "true-false",
          "question": "catchError operator handles errors by replacing with fallback.",
          "correctAnswer": "true",
          "explanation": "catchError catches errors in the observable chain and maps them to a new observable, like a fallback value or rethrow.",
          "points": 10
        },
        {
          "id": "q2",
          "type": "single-choice",
          "question": "retry operator resubscribes on error a specified number of times.",
          "options": [
            "Once only",
            "Infinite times",
            "Specified times by parameter",
            "Never, use retryWhen"
          ],
          "correctAnswer": 2,
          "explanation": "retry(n) automatically retries failed emissions up to n times, ideal for transient errors like network issues.",
          "points": 10
        },
        {
          "id": "q3",
          "type": "true-false",
          "question": "Observables must be subscribed to emit values.",
          "correctAnswer": "true",
          "explanation": "Observables are lazy; subscription triggers execution and value emission to observers.",
          "points": 10
        },
        {
          "id": "q4",
          "type": "true-false",
          "question": "finalize executes regardless of complete or error.",
          "correctAnswer": "true",
          "explanation": "finalize runs cleanup code (e.g., unsubscribes) on completion, error, or unsubscription.",
          "points": 10
        },
        {
          "id": "q5",
          "type": "true-false",
          "question": "Higher-order observables require flattening operators like switchMap.",
          "correctAnswer": "true",
          "explanation": "Operators returning observables (e.g., switchMap) flatten inner streams to manage multiple observables effectively.",
          "points": 10
        }
      ]
    },
    {
      "id": "quiz-requirements-engineering",
      "courseId": "requirements-engineering",
      "title": "Requirements Engineering Assessment",
      "description": "Evaluate your mastery of requirements engineering practices",
      "passingScore": 70,
      "timeLimit": 20,
      "questions": [
        {
          "id": "q1",
          "type": "true-false",
          "question": "SRS includes both functional and non-functional requirements.",
          "correctAnswer": "true",
          "explanation": "SRS details what the system does (functional) and qualities like performance, security (non-functional).",
          "points": 10
        },
        {
          "id": "q2",
          "type": "true-false",
          "question": "Traceability links requirements to design and tests.",
          "correctAnswer": "true",
          "explanation": "Bidirectional traceability ensures coverage, verifies implementation, and tracks changes across artifacts.",
          "points": 10
        },
        {
          "id": "q3",
          "type": "true-false",
          "question": "Change management starts with identification and evaluation.",
          "correctAnswer": "true",
          "explanation": "Process captures requests, assesses impact, approves, implements, and documents to control scope creep.",
          "points": 10
        },
        {
          "id": "q4",
          "type": "single-choice",
          "question": "Performance requirements in SRS are always dynamic.",
          "options": [
            "True",
            "False, include static and dynamic",
            "Only static",
            "Not part of SRS"
          ],
          "correctAnswer": 1,
          "explanation": "Dynamic constraints execution behavior (e.g., response time); static do not (e.g., memory limits).",
          "points": 10
        },
        {
          "id": "q5",
          "type": "true-false",
          "question": "Requirements documentation must be complete and verifiable.",
          "correctAnswer": "true",
          "explanation": "Good SRS is unambiguous, complete, verifiable, and traceable for successful development and validation.",
          "points": 10
        }
      ]
    }
  ]
}
